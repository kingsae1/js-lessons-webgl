  <div id="readme" class="readme blob instapaper_body">
    <article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-projectbs-s63-webgl---day-2" class="anchor" href="#projectbs-s63-webgl---day-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ProjectBS S63 WebGL - Day 2</h1>

<h2><a id="user-content-프로그래밍-일반" class="anchor" href="#프로그래밍-일반" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로그래밍 일반</h2>

<h3><a id="user-content-html" class="anchor" href="#html" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTML</h3>

<blockquote>
<p><strong>HTML</strong>은 다양한 형태의 미디어를 포함할 수 있는 <strong>컨테이너 시스템</strong>이다.</p>

<ul>
<li>HTML은 태그(tag)로 되어 있고, <strong>태그로만 되어 있다</strong>.</li>
<li>HTML의 태그는 컨테이너다. 이미지를 보여주는 <strong><code>img</code></strong>, 비디오를 보여주는 <strong><code>video</code></strong>, 오디오를 들려주는 <strong><code>audio</code></strong>, 그림을 그릴 수 있게 해주는 <strong><code>canvas</code></strong> 등 각자 상이한 시스템들이 모두 이 컨테이너에 담겨져서, <strong>컨테이너에 담겨져야만 HTML내에 들어올 수 있다</strong>.</li>
</ul>
</blockquote>

<h3><a id="user-content-상태state" class="anchor" href="#상태state" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상태(State)</h3>

<blockquote>
<p>상태는 <strong>지속되는 변수</strong>를 말한다.</p>

<ul>
<li>상태는 <strong>스코프(Scope)</strong>라는 생존 기간, 생존 공간, 생존 범위 동안 그 <strong>값을 유지</strong>할 수 있고, 그 <strong>값을 변경</strong>할 수도 있다.</li>
<li><strong>상태는 변경되기 전까지는 기존의 상태를 그대로 유지한다.</strong></li>
</ul>
</blockquote>

<p>사람은 대체로 상태라는 개념에 익숙하다. 가장 널리 사용되는 프로그래밍 언어인 C, Java, JavaScript는 모두 사람에게 익숙한 상태를 다루는 <strong>ALGOL60</strong> 이라는 언어에서 파생되어 발전해온 언어이다.</p>

<p><strong>사람이 상태에 익숙하기는 하지만 여러 상태를 한꺼번에 관리해야 할 때 특정 시점, 특정 상황에서 여러 상태를 정확히 파악하기는 어려운 일이다</strong>. 상태를 파악하기 어렵기 때문에 <strong>조건문을 통해 상태를 확인</strong>하게 된다. <strong>조건문이나 반복문을 통해 상태를 다루는 프로그래밍 언어를 제어형(또는 절차형) 언어</strong>라고 한다.</p>

<p>조건문의 과도한 사용은 또다시 상태의 파악을 어렵게 하는 요인이 된다. <strong>객체 지향이나 디자인 패턴은 궁극적으로는 과도한 조건문의 사용을 막는 것을 목적</strong>으로 한다.</p>

<h3><a id="user-content-상태-머신state-machine" class="anchor" href="#상태-머신state-machine" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상태 머신(State Machine)</h3>

<blockquote>
<p>말 그대로 <strong>상태를 다루는 기계</strong>이다.</p>

<ul>
<li>상태 머신은 상태를 포함하며, 외부에서 상태에 직접 접근하지 못하게 하고, <strong>상태 머신을 통해서만 접근을 허용</strong>한다.</li>
<li>상태 머신은 포함하고 있는 <strong>상태가 변할 때, 상태 머신에 정의되어 있는 다른 일도 할 수 있다</strong>.</li>
<li>상태 머신은 객체 지향에서 말하는 캡슐화와 비슷한 면이 있다.</li>
</ul>
</blockquote>

<p>상태 머신의 예는 매우 다양하다.</p>

<p>워드를 떠올려 보자.
워드에서 글자색을 빨간색으로 설정하면 그 이후에 입력하는 모든 글자는, <strong>글자색을 다른 색으로 변경하기 전까지는  빨간색으로 화면에 표시</strong>된다.
이때 빨간색으로 설정하는 행위는 <strong>상태 머신이 제공하는 API를 통해서 글자색이라는 상태를 변경</strong>하며,
빨간색으로 설정되면 글자만 빨간색으로 표시하는 것이 아니라 <strong>상태 머신에 정의된 대로 글자색 아이콘의 색상도 빨간색으로 표시</strong>한다. </p>

<h3><a id="user-content-컨텍스트context" class="anchor" href="#컨텍스트context" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>컨텍스트(Context)</h3>

<blockquote>
<p>컨텍스트는 어떤 일을 진짜로, 실제로 수행하는 담당자.</p>

<ul>
<li>담당자는 <strong>어떤 일을 수행하기 위해 필요한 정보, 어떤 일이 수행될 수 있는 환경</strong>을 가지고 있다.</li>
</ul>
</blockquote>

<p>컨텍스트(담당자)의 예를 들어 보면,</p>

<ul>
<li>style 태그의 담당자는 Sheet 객체.</li>
<li>canvas 태그의 담당자는 2D Context, WebGL Context </li>
</ul>

<p>하나의 HTML은 여러 개의 canvas를 가질 수 있고, canvas마다 각각 자기만의 context를 갖는다.</p>

<p><strong>GPU는 WebGL 만 처리하는 것이 아니라 OS에 의해 WebGL 외의 여러가지 일을 처리</strong>한다. 이 과정에서 GPU 자원이 부족해지면 <strong>임의로 WebGL 컨텍스트를 소멸</strong>시키기도 한다. 이를 <strong>WebGL 컨텍스트 상실</strong>이라고 하는데, 관련 내용은 책 4장에서 다루고 있다.</p>

<h2><a id="user-content-삼각형-그리기-코드-해부" class="anchor" href="#삼각형-그리기-코드-해부" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>삼각형 그리기 코드 해부</h2>

<p>WebGL에서의 Hello, World는 기본 Primitive인 삼각형 그리기다.</p>

<h3><a id="user-content-큰-구조" class="anchor" href="#큰-구조" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>큰 구조</h3>

<p><a href="https://camo.githubusercontent.com/f881071bdbd8ae8fa5613a4a391520b682dd1b62/687474703a2f2f692e696d6775722e636f6d2f70457876544f782e706e67" target="_blank"><img src="https://camo.githubusercontent.com/f881071bdbd8ae8fa5613a4a391520b682dd1b62/687474703a2f2f692e696d6775722e636f6d2f70457876544f782e706e67" alt="" data-canonical-src="http://i.imgur.com/pExvTOx.png" style="max-width:100%;"></a></p>

<h3><a id="user-content-코드-해부" class="anchor" href="#코드-해부" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>코드 해부</h3>

<p><a href="https://github.com/projectBS/S63-WebGL/blob/master/Day2-Triangle.html">github.com/projectBS/S63-WebGL/blob/master/Day2-Triangle.html</a></p>

<h4><a id="user-content-상태-머신" class="anchor" href="#상태-머신" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상태 머신</h4>

<p><code>gl.useProgram()</code>, <code>gl.bindBuffer()</code>, <code>gl.clearColor()</code> 등 상태 머신을 통해 지정된 GPU 쪽 상태의 스코프는 JavaScript의 스코프와 무관하다.</p>

<p>예를 들어 JavaScript 함수인 <code>setupBuffers()</code> 내에서 <code>gl.bindBuffer()</code>에 의해 지정된 상태는, <code>setupBuffers()</code>의 실행이 종료되어도 GPU 내에서 그대로 유지되어, JavaScript의 다른 함수인 <code>draw()</code> 내의 <code>gl.drawArrays()</code>가 실행될 때까지도 유효하다.</p>

<h4><a id="user-content-glcreatebuffer-glbindbuffer-glbufferdata" class="anchor" href="#glcreatebuffer-glbindbuffer-glbufferdata" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>gl.createBuffer(), gl.bindBuffer(), gl.bufferData()</h4>

<p>gl은 상태 머신으로 다음과 유사한 자료 구조 형식을 가지고 있다. 아래에 나오는 코드는 모두 CPU가 아니라 GPU 내에 생성되는 자료 구조를 의미한다.</p>

<div class="highlight highlight-source-js"><pre>gl <span class="pl-k">=</span> {
    key0<span class="pl-k">:</span> value0,
    key1<span class="pl-k">:</span> value1,
    <span class="pl-k">...</span>,
    ARRAY_BUFFER<span class="pl-k">:</span> <span class="pl-c1">0x8892</span>,
    <span class="pl-k">...</span>
};</pre></div>

<p><code>vertexBuffer1 = gl.createBuffer()</code>를 실행하면 GPU 메모리 내에 배열을 생성한다.</p>

<div class="highlight highlight-source-js"><pre>gl <span class="pl-k">=</span> {
    key0<span class="pl-k">:</span> value0,
    key1<span class="pl-k">:</span> value1,
    <span class="pl-k">...</span>,
    ARRAY_BUFFER<span class="pl-k">:</span> <span class="pl-c1">0x8892</span>,
    <span class="pl-k">...</span>,
    vertexBuffer1 <span class="pl-k">=</span> [],
    <span class="pl-k">...</span>
};</pre></div>

<p><code>gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer1)</code>를 실행하는 것은 <code>gl[gl.ARRAY_BUFFER] = vertexBuffer1</code>를 실행하는 것과 비슷하다.</p>

<div class="highlight highlight-source-js"><pre>gl <span class="pl-k">=</span> {
    key0<span class="pl-k">:</span> value0,
    key1<span class="pl-k">:</span> value1,
    <span class="pl-k">...</span>,
    ARRAY_BUFFER<span class="pl-k">:</span> <span class="pl-c1">0x8892</span>,
    <span class="pl-k">...</span>,
    vertexBuffer1 <span class="pl-k">=</span> [],
    <span class="pl-k">...</span>,
    <span class="pl-c1">0x8892</span><span class="pl-k">:</span> vertexBuffer1,
    <span class="pl-k">...</span>
};</pre></div>

<p><code>gl.bufferData(gl.ARRAY_BUFFER, typedArray, gl.STATIC_DRAW)</code>를 실행하면, <code>gl[gl.ARRAY_BUFFER]</code>, 즉,  <code>gl[0x8892]</code>, 즉, <code>vertexBuffer1</code>에 <code>typedArray</code><strong>의 데이터를 복사</strong>한다. </p>

<div class="highlight highlight-source-js"><pre>gl <span class="pl-k">=</span> {
    key0<span class="pl-k">:</span> value0,
    key1<span class="pl-k">:</span> value1,
    <span class="pl-k">...</span>,
    ARRAY_BUFFER<span class="pl-k">:</span> <span class="pl-c1">0x8892</span>,
    <span class="pl-k">...</span>,
    vertexBuffer1 <span class="pl-k">=</span> [ <span class="pl-c1">0.0</span>,  <span class="pl-c1">0.5</span>,  <span class="pl-c1">0.0</span>, <span class="pl-k">-</span><span class="pl-c1">0.5</span>, <span class="pl-k">-</span><span class="pl-c1">0.5</span>,  <span class="pl-c1">0.0</span>, <span class="pl-c1">0.5</span>, <span class="pl-k">-</span><span class="pl-c1">0.5</span>,  <span class="pl-c1">0.0</span> ],
    <span class="pl-k">...</span>,
    <span class="pl-c1">0x8892</span><span class="pl-k">:</span> vertexBuffer1,
    <span class="pl-k">...</span>
};</pre></div>

<p>이 시점부터 GPU가 Array Buffer를 사용할 때는 별다른 지시 없이도 현재 <code>gl[gl.ARRAY_BUFFER]</code>, 즉,  <code>gl[0x8892]</code>, 즉, <code>vertexBuffer1</code><strong>에 있는 Array Buffer를 사용하게 된다.</strong></p>

<ol>
<li>vertexBuffer2 = gl.createBuffer();</li>
<li>gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer2);</li>
</ol>

<p>를 차례로 실행하면 아래와 같이 된다.</p>

<div class="highlight highlight-source-js"><pre>gl <span class="pl-k">=</span> {
    key0<span class="pl-k">:</span> value0,
    key1<span class="pl-k">:</span> value1,
    <span class="pl-k">...</span>,
    ARRAY_BUFFER<span class="pl-k">:</span> <span class="pl-c1">0x8892</span>,
    <span class="pl-k">...</span>,
    vertexBuffer1 <span class="pl-k">=</span> [],
    <span class="pl-k">...</span>,
    <span class="pl-c1">0x8892</span><span class="pl-k">:</span> vertexBuffer2,  <span class="pl-c">// 2. gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer2)의 결과</span>

    <span class="pl-k">...</span>,
    vertexBuffer2 <span class="pl-k">=</span> [],  <span class="pl-c">// 1. vertexBuffer2 = gl.createBuffer()의 결과</span>
    <span class="pl-k">...</span>
};</pre></div>

<p>이 시점부터 GPU가 <strong>Array Buffer</strong>를 사용할 때는 별다른 지시 없이도 현재 <code>gl[gl.ARRAY_BUFFER]</code>, 즉,  <code>gl[0x8892]</code>, 즉, <code>vertexBuffer2</code>에 있는 <strong>Array Buffer</strong>를 사용하게 된다.</p>

<h4><a id="user-content-glcreateshader-glcreateprogram-glcreatebuffer" class="anchor" href="#glcreateshader-glcreateprogram-glcreatebuffer" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>gl.createShader(), gl.createProgram(), gl.createBuffer()</h4>

<blockquote>
<p>gl.createShader(), gl.createProgram(), gl.createBuffer()는 GPU에게 뭔가를 실어 보낼 그릇을 반환한다. </p>

<ul>
<li>좀더 정확하게는 GPU 메모리 내에 각각 Shader 객체, Program 객체, Buffer 객체를 위한 공간을 할당하고 그 객체를, 즉 GPU 메모리 내부에 대한 포인터를 반환한다. </li>
<li>하지만 CPU 쪽(JavaScript)에서 이 포인터를 통해 GPU 내의 자원에 직접 접근할 수는 없다.</li>
</ul>
</blockquote>

<p>실제로 코드를 자세히 보면, <code>gl.createShader()</code>, <code>gl.createProgram()</code>, <code>gl.createBuffer()</code>에 의해 반환되는 <code>shader</code>, <code>program</code>, <code>buffer</code>는 <code>shader.어쩌구</code>, <code>program.어쩌구</code>, <code>buffer.어쩌구</code> 하는 식으로 <strong>GPU의 자원에 직접 접근하는 코드는 없다.</strong>(<code>vertexBuffer.itemsPerVertex = 3;</code>와 같은 코드에서 <code>itemsPerVertex</code>는 단순히 3이라는 값을 나중에 사용하기 위해 편의상 캐쉬해두는 사용자 변수일 뿐 GPU에 자원에 접근할 수 있는 내장 변수가 아니다.)</p>

<p>대신에 <strong>언제나 <code>gl.method()</code>의 파라미터로만 사용</strong>된다. 즉, <strong>언제나 GPU에 무언가를 실어나르는 그릇 용도로만 사용</strong>된다. </p>

<h2><a id="user-content-cpu---gpu-데이터-통신-정리" class="anchor" href="#cpu---gpu-데이터-통신-정리" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CPU - GPU 데이터 통신 정리</h2>

<p><a href="https://camo.githubusercontent.com/3e1186e8e9b2a115ca982d12d919d5650ac434b4/687474703a2f2f692e696d6775722e636f6d2f5365576c6b6e742e706e67" target="_blank"><img src="https://camo.githubusercontent.com/3e1186e8e9b2a115ca982d12d919d5650ac434b4/687474703a2f2f692e696d6775722e636f6d2f5365576c6b6e742e706e67" alt="" data-canonical-src="http://i.imgur.com/SeWlknt.png" style="max-width:100%;"></a></p>

<h3><a id="user-content-cpu의-역할" class="anchor" href="#cpu의-역할" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CPU의 역할</h3>

<blockquote>
<p>사용자 이벤트 관련 데이터와 그리는데 필요한 값 및 메타데이터, 셰이더를 gl컨텍스트에 실어서 GPU에게 보낸다.</p>

<ul>
<li>GPU 자원의 할당/해제는 언제나 gl컨텍스트를 통해 GPU에 시키는 형태로 수행된다.</li>
</ul>
</blockquote>

<h3><a id="user-content-gpu의-역할" class="anchor" href="#gpu의-역할" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GPU의 역할</h3>

<blockquote>
<p>CPU로부터 받은 셰이더를 파이프라인에 끼워 넣고, CPU로부터 받은 데이터를 다수의 코어에서 파이프라인을 통해 처리하고 결과를 Frame Buffer에 쓴다.</p>

<ul>
<li>CPU로부터 받을 수 있는 데이터의 형식은 숫자와 이미지 두 가지 뿐이며, CPU에게는 데이터를 담을 그릇을 반환할 뿐 그 외의 어떤 데이터도 전달하지 않는다.</li>
</ul>
</blockquote>
</article>
  </div>

</div>
